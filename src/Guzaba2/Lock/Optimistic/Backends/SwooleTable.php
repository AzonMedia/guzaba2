<?php

namespace Guzaba2\Lock\Backends;

use Guzaba2\Base\Base;
use Guzaba2\Base\Exceptions\InvalidArgumentException;
use Guzaba2\Base\Exceptions\RunTimeException;
use Guzaba2\Coroutine\Coroutine;
use Guzaba2\Orm\ActiveRecord;
use Guzaba2\Translator\Translator as t;

/**
 * Class SwooleTable
 * Keeps lock information in Swoole\Table
 * Because of the nature of Swoole\Table the instance needs to be created BEFORE the server is started. This way the same Swoole\Table will be shared between the workers.
 *
 * During an object update the lock must be updated either to 0 or to a time in future (if there is a timeout for the object update).
 * Such a time out could be the transaction timeout in SQL.
 * This is needed so that the object is not retrieved by the cache while being updated.
 * Otherwise it may happen the object to be updated in the permanent storage (transaction committed) and the update/lock data not have been updated yet and an old version of the object to get pulled.
 *
 * It also caches the last access time
 *
 * @package Guzaba2\Lock\Backends
 */
class SwooleTable extends Base
{
    protected const CONFIG_DEFAULTS = [
        'max_rows'                      => 100000,
        'cleanup_at_percentage_usage'   => 95,//when the cleanup should be triggered
        'cleanup_percentage_records'    => 20,//the percentage of records to be removed
    ];

    protected const CONFIG_RUNTIME = [];

    /**
     * @var \Swoole\Table
     */
    protected $SwooleTable;

    public const DATA_STRUCT = [
        'updated_microtime'         => 'float',
        'updated_from_worker_id'    => 'int',
        'updated_from_coroutine_id' => 'int',
    ];


    public function __construct()
    {
        parent::__construct();
        if (Coroutine::inCoroutine()) {
            throw new RunTimeException(sprintf(t::_('Instances from %s need to be created before the swoole server is started. This instance is created in a coroutine whcih suggests it is being created inside the request (or other) handler of the server.'), __CLASS__));
        }

        $this->SwooleTable = new \Swoole\Table(static::CONFIG_RUNTIME['max_rows']);
        //the key will be the class name with the index
        //the data consists of last modified microtime, worker id, coroutine id
        //$this->SwooleTable->column('updated_microtime', \Swoole\Table::TYPE_FLOAT);
        //$this->SwooleTable->column('updated_from_worker_id', \Swoole\Table::TYPE_INT);
        //$this->SwooleTable->column('updated_from_coroutine_id', \Swoole\Table::TYPE_INT);
        foreach (self::DATA_STRUCT as $key=>$php_type) {
            $this->SwooleTable->column($key, \Guzaba2\Swoole\Table::TYPES_MAP[$php_type]);
        }
        $this->SwooleTable->create();
    }

    /**
     * Destroys the SwooleTable
     */
    public function __destruct()
    {
        $this->SwooleTable->destroy();
        $this->SwooleTable = NULL;
        parent::__destruct(); // TODO: Change the autogenerated stub
    }

    /**
     * @param string $key
     * @return array|null
     */
    public function get_update_data(string $key) : ?array
    {
        return $this->SwooleTable->get($key);
    }

    /**
     * @param ActiveRecord $ActiveRecord
     * @return array|null
     */
    public function get_update_data_by_object(ActiveRecord $ActiveRecord) : ?array
    {
        $key = self::get_key($ActiveRecord);
        return $this->get_update_data($key);
    }

    /**
     * @param string $key
     * @return float|null
     */
    public function get_last_update_time(string $key) : ?float
    {
        $ret = NULL;
        $data = $this->get_update_data($key);
        if (isset($data['updated_microtime'])) {
            $ret = $data['updated_microtime'];
        }
        return $ret;
    }

    /**
     * @param ActiveRecord $ActiveRecord
     * @return float|null
     */
    public function get_last_update_time_by_object(ActiveRecord $ActiveRecord) : ?float
    {
        $key = self::get_key($ActiveRecord);
        return $this->get_last_update_time($key);
    }


    /**
     * To be invoked when a record is updated or when a record is not present in the SwooleTable and was accessed and the lock information needs to be updated.
     * @param string $key
     * @param array $data
     * @throws InvalidArgumentException
     */
    public function set_update_data(string $key, array $data) : void
    {
        self::validate_data($data);
        $this->set($key, $data);
        if (count($this->SwooleTable) > self::CONFIG_RUNTIME['max_rows'] * (self::CONFIG_RUNTIME['cleanup_at_percentage_usage'] / 100)) {
            //95% usage is reached - cleanup is needed
            //the cleanup cleans more records than just 1 or few... If just a few are cleaned then the cleanup will be invoked much more often
            $this->cleanup();
        }
    }

    /**
     * @param ActiveRecord $activeRecord
     * @param array $data
     * @throws InvalidArgumentException
     */
    public function set_update_data_by_object(ActiveRecord $activeRecord, array $data) : void
    {
        $key = self::get_key($ActiveRecord);
        $this->set_update_data($key, $data);
    }

    /**
     * Removes certain keys from the SwooleTable storage.
     * It is triggered when the number of records reach cleanup_at_percentage_usage
     * The number of records removed is cleanup_percentage_records
     */
    protected function cleanup() : void
    {
        //TODO implement
    }


    protected static function get_key(ActiveRecord $ActiveRecord) : string
    {
        $class = get_class($ActiveRecord);
        $lookup_index = $ActiveRecord->get_lookup_index();
        $key = $class.'_'.$lookup_index;
        return $key;
    }

    /**
     * Validates the provided lock data.
     * Throws InvalidArgumentException on data error.
     * @param array $data
     * @throws InvalidArgumentException
     */
    protected static function validate_data(array $data) : void
    {
        foreach ($data as $key=>$value) {
            if (!isset(self::DATA_STRUCT[$key])) {
                throw new InvalidArgumentException(sprintf(t::_('The provided lock data contains an unsupported key %s.'), $key));
            } elseif (gettype($value) !== self::DATA_STRUCT[$key]) {
                throw new InvalidArgumentException(sprintf(t::_('The provided lock data contains key %s which has a value of type % while it must be of type %s'), $key, gettype($value), self::DATA_STRUCT[$key]));
            }
        }
        if (count($data) !== count(self::DATA_STRUCT)) {
            throw new InvalidArgumentException(sprintf(t::_('The provided data contains less keys %s than the expected in DATA_STRUCT %s.'), count($data), count(self::DATA_STRUCT)));
        }
    }
}
